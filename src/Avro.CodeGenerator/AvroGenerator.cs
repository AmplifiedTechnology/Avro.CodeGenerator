using Avro;
using Microsoft.CodeAnalysis;
using Microsoft.CSharp;
using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.IO;
using System.Linq;

namespace CodeGenerator
{
    [Generator]
    public class AvroGenerator : ISourceGenerator
    {
        internal const string Header = "//This file was auto-generated by Avro.CodeGenerator";

        internal static Action<string, string> ProcessAvroGenResult = (path, avrogenResults) => File.WriteAllText(path, avrogenResults);

        public void Initialize(GeneratorInitializationContext context)
        {
            //#if DEBUG
            //            Debugger.Launch();
            //#endif
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var avroFiles = context.AdditionalFiles.Select(file => file.Path).Where(file => Path.GetExtension(file) == ".avro").ToList();

            var baseNamespace = context.Compilation.AssemblyName;

            foreach (var avroFile in avroFiles)
            {
                var avroCodeFileName = $"{avroFile}.g.cs";
                if (File.Exists(avroCodeFileName))
                {
                    continue;
                }

                var folderPath = Path.GetDirectoryName(avroFile);

                var codeNamespace = GetCodeNamespace(baseNamespace, folderPath);

                var avroSchema = File.ReadAllText(avroFile);

                var avroClass = AvroGen(avroSchema, codeNamespace);

                ProcessAvroGenResult(avroCodeFileName, avroClass);
            }
        }

        internal static string GetCodeNamespace(string baseNamespace, string folderPath)
        {
            if (TryGetFolderPathIndexFromBaseNamespace(baseNamespace, folderPath, out var startIndex, out var folderPathIndex))
            {
                var folder = folderPath.Substring(folderPathIndex + 1);
                if (folder.Length > 0)
                {
                    return $"{baseNamespace}.{folder.Replace("\\", ".")}";
                }
            }

            return baseNamespace;
        }

        private static bool TryGetFolderPathIndexFromBaseNamespace(string baseNamespace, string folderPath, out int startIndex, out int folderPathIndex)
        {
            startIndex = folderPathIndex = -1;
            return (startIndex = folderPath.LastIndexOf(baseNamespace)) != -1 && (folderPathIndex = folderPath.IndexOf('\\', startIndex)) != -1;
        }

        internal static string AvroGen(string avroSchema, string codeNamespace)
        {
            var codeGen = new CodeGen();

            codeGen.AddSchema(avroSchema);

            codeGen.GenerateCode();

            var cSharpCodeProvider = new CSharpCodeProvider();

            var opts = new CodeGeneratorOptions();
            opts.BracingStyle = "C";
            opts.IndentString = "    ";
            opts.BlankLinesBetweenMembers = true;

            var namespaces = codeGen.CompileUnit.Namespaces;

            var @namespace = namespaces.Count > 0 ? @namespaces[0] : throw new Exception($"Assertion: namespace not found in schema: {avroSchema}");

            var newNamespace = new CodeNamespace(codeNamespace);

            newNamespace.Comments.Add(CodeGenUtil.Instance.FileComment);

            foreach (var namespaceImport in CodeGenUtil.Instance.NamespaceImports)
            {
                newNamespace.Imports.Add(namespaceImport);
            }

            var codeTypeDeclaration = @namespace.Types.Count > 0 ? @namespace.Types[0] : throw new Exception($"Assertion: type definition not found in schema: {avroSchema}");

            newNamespace.Types.Add(codeTypeDeclaration);

            using (var writer = new StringWriter())
            {
                cSharpCodeProvider.GenerateCodeFromNamespace(newNamespace, writer, opts);

                writer.Flush();

                return string.Concat(Header, Environment.NewLine, writer.ToString());
            }
        }
    }
}